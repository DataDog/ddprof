// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0. This product includes software
// developed at Datadog (https://www.datadoghq.com/). Copyright 2021-Present
// Datadog, Inc.

#pragma once

#include <map>
#include <string>

// Architecture mapfile

#ifndef __x86_64__
#error Not supported on your current architecture
#endif

#define SYSCALL_TABLE(X) \
  X(0,   read) \
  X(1,   write) \
  X(2,   open) \
  X(3,   close) \
  X(4,   stat) \
  X(5,   fstat) \
  X(6,   lstat) \
  X(7,   poll) \
  X(8,   lseek) \
  X(9,   mmap) \
  X(10,  mprotect) \
  X(11,  munmap) \
  X(12,  brk) \
  X(13,  rt_sigaction) \
  X(14,  rt_sigprocmask) \
  X(15,  rt_sigreturn) \
  X(16,  ioctl) \
  X(17,  pread64) \
  X(18,  pwrite64) \
  X(19,  readv) \
  X(20,  writev) \
  X(21,  access) \
  X(22,  pipe) \
  X(23,  select) \
  X(24,  sched_yield) \
  X(25,  mremap) \
  X(26,  msync) \
  X(27,  mincore) \
  X(28,  madvise) \
  X(29,  shmget) \
  X(30,  shmat) \
  X(31,  shmctl) \
  X(32,  dup) \
  X(33,  dup2) \
  X(34,  pause) \
  X(35,  nanosleep) \
  X(36,  getitimer) \
  X(37,  alarm) \
  X(38,  setitimer) \
  X(39,  getpid) \
  X(40,  sendfile) \
  X(41,  socket) \
  X(42,  connect) \
  X(43,  accept) \
  X(44,  sendto) \
  X(45,  recvfrom) \
  X(46,  sendmsg) \
  X(47,  recvmsg) \
  X(48,  shutdown) \
  X(49,  bind) \
  X(50,  listen) \
  X(51,  getsockname) \
  X(52,  getpeername) \
  X(53,  socketpair) \
  X(54,  setsockopt) \
  X(55,  getsockopt) \
  X(56,  clone) \
  X(57,  fork) \
  X(58,  vfork) \
  X(59,  execve) \
  X(60,  exit) \
  X(61,  wait4) \
  X(62,  kill) \
  X(63,  uname) \
  X(64,  semget) \
  X(65,  semop) \
  X(66,  semctl) \
  X(67,  shmdt) \
  X(68,  msgget) \
  X(69,  msgsnd) \
  X(70,  msgrcv) \
  X(71,  msgctl) \
  X(72,  fcntl) \
  X(73,  flock) \
  X(74,  fsync) \
  X(75,  fdatasync) \
  X(76,  truncate) \
  X(77,  ftruncate) \
  X(78,  getdents) \
  X(79,  getcwd) \
  X(80,  chdir) \
  X(81,  fchdir) \
  X(82,  rename) \
  X(83,  mkdir) \
  X(84,  rmdir) \
  X(85,  creat) \
  X(86,  link) \
  X(87,  unlink) \
  X(88,  symlink) \
  X(89,  readlink) \
  X(90,  chmod) \
  X(91,  fchmod) \
  X(92,  chown) \
  X(93,  fchown) \
  X(94,  lchown) \
  X(95,  umask) \
  X(96,  gettimeofday) \
  X(97,  getrlimit) \
  X(98,  getrusage) \
  X(99,  sysinfo) \
  X(100, times) \
  X(101, ptrace) \
  X(102, getuid) \
  X(103, syslog) \
  X(104, getgid) \
  X(105, setuid) \
  X(106, setgid) \
  X(107, geteuid) \
  X(108, getegid) \
  X(109, setpgid) \
  X(110, getppid) \
  X(111, getpgrp) \
  X(112, setsid) \
  X(113, setreuid) \
  X(114, setregid) \
  X(115, getgroups) \
  X(116, setgroups) \
  X(117, setresuid) \
  X(118, getresuid) \
  X(119, setresgid) \
  X(120, getresgid) \
  X(121, getpgid) \
  X(122, setfsuid) \
  X(123, setfsgid) \
  X(124, getsid) \
  X(125, capget) \
  X(126, capset) \
  X(127, rt_sigpending) \
  X(128, rt_sigtimedwait) \
  X(129, rt_sigqueueinfo) \
  X(130, rt_sigsuspend) \
  X(131, sigaltstack) \
  X(132, utime) \
  X(133, mknod) \
  X(134, uselib) \
  X(135, personality) \
  X(136, ustat) \
  X(137, statfs) \
  X(138, fstatfs) \
  X(139, sysfs) \
  X(140, getpriority) \
  X(141, setpriority) \
  X(142, sched_setparam) \
  X(143, sched_getparam) \
  X(144, sched_setscheduler) \
  X(145, sched_getscheduler) \
  X(146, sched_get_priority_max) \
  X(147, sched_get_priority_min) \
  X(148, sched_rr_get_interval) \
  X(149, mlock) \
  X(150, munlock) \
  X(151, mlockall) \
  X(152, munlockall) \
  X(153, vhangup) \
  X(154, modify_ldt) \
  X(155, pivot_root) \
  X(156, _sysctl) \
  X(157, prctl) \
  X(158, arch_prctl) \
  X(159, adjtimex) \
  X(160, setrlimit) \
  X(161, chroot) \
  X(162, sync) \
  X(163, acct) \
  X(164, settimeofday) \
  X(165, mount) \
  X(166, umount2) \
  X(167, swapon) \
  X(168, swapoff) \
  X(169, reboot) \
  X(170, sethostname) \
  X(171, setdomainname) \
  X(172, iopl) \
  X(173, ioperm) \
  X(174, create_module) \
  X(175, init_module) \
  X(176, delete_module) \
  X(177, get_kernel_syms) \
  X(178, query_module) \
  X(179, quotactl) \
  X(180, nfsservctl) \
  X(181, getpmsg) \
  X(182, putpmsg) \
  X(183, afs_syscall) \
  X(184, tuxcall) \
  X(185, security) \
  X(186, gettid) \
  X(187, readahead) \
  X(188, setxattr) \
  X(189, lsetxattr) \
  X(190, fsetxattr) \
  X(191, getxattr) \
  X(192, lgetxattr) \
  X(193, fgetxattr) \
  X(194, listxattr) \
  X(195, llistxattr) \
  X(196, flistxattr) \
  X(197, removexattr) \
  X(198, lremovexattr) \
  X(199, fremovexattr) \
  X(200, tkill) \
  X(201, time) \
  X(202, futex) \
  X(203, sched_setaffinity) \
  X(204, sched_getaffinity) \
  X(205, set_thread_area) \
  X(206, io_setup) \
  X(207, io_destroy) \
  X(208, io_getevents) \
  X(209, io_submit) \
  X(210, io_cancel) \
  X(211, get_thread_area) \
  X(212, lookup_dcookie) \
  X(213, epoll_create) \
  X(214, epoll_ctl_old) \
  X(215, epoll_wait_old) \
  X(216, remap_file_pages) \
  X(217, getdents64) \
  X(218, set_tid_address) \
  X(219, restart_syscall) \
  X(220, semtimedop) \
  X(221, fadvise64) \
  X(222, timer_create) \
  X(223, timer_settime) \
  X(224, timer_gettime) \
  X(225, timer_getoverrun) \
  X(226, timer_delete) \
  X(227, clock_settime) \
  X(228, clock_gettime) \
  X(229, clock_getres) \
  X(230, clock_nanosleep) \
  X(231, exit_group) \
  X(232, epoll_wait) \
  X(233, epoll_ctl) \
  X(234, tgkill) \
  X(235, utimes) \
  X(236, vserver) \
  X(237, mbind) \
  X(238, set_mempolicy) \
  X(239, get_mempolicy) \
  X(240, mq_open) \
  X(241, mq_unlink) \
  X(242, mq_timedsend) \
  X(243, mq_timedreceive) \
  X(244, mq_notify) \
  X(245, mq_getsetattr) \
  X(246, kexec_load) \
  X(247, waitid) \
  X(248, add_key) \
  X(249, request_key) \
  X(250, keyctl) \
  X(251, ioprio_set) \
  X(252, ioprio_get) \
  X(253, inotify_init) \
  X(254, inotify_add_watch) \
  X(255, inotify_rm_watch) \
  X(256, migrate_pages) \
  X(257, openat) \
  X(258, mkdirat) \
  X(259, mknodat) \
  X(260, fchownat) \
  X(261, futimesat) \
  X(262, newfstatat) \
  X(263, unlinkat) \
  X(264, renameat) \
  X(265, linkat) \
  X(266, symlinkat) \
  X(267, readlinkat) \
  X(268, fchmodat) \
  X(269, faccessat) \
  X(270, pselect6) \
  X(271, ppoll) \
  X(272, unshare) \
  X(273, set_robust_list) \
  X(274, get_robust_list) \
  X(275, splice) \
  X(276, tee) \
  X(277, sync_file_range) \
  X(278, vmsplice) \
  X(279, move_pages) \
  X(280, utimensat) \
  X(281, epoll_pwait) \
  X(282, signalfd) \
  X(283, timerfd_create) \
  X(284, eventfd) \
  X(285, fallocate) \
  X(286, timerfd_settime) \
  X(287, timerfd_gettime) \
  X(288, accept4) \
  X(289, signalfd4) \
  X(290, eventfd2) \
  X(291, epoll_create1) \
  X(292, dup3) \
  X(293, pipe2) \
  X(294, inotify_init1) \
  X(295, preadv) \
  X(296, pwritev) \
  X(297, rt_tgsigqueueinfo) \
  X(298, perf_event_open) \
  X(299, recvmmsg) \
  X(300, fanotify_init) \
  X(301, fanotify_mark) \
  X(302, prlimit64) \
  X(303, name_to_handle_at) \
  X(304, open_by_handle_at) \
  X(305, clock_adjtime) \
  X(306, syncfs) \
  X(307, sendmmsg) \
  X(308, setns) \
  X(309, getcpu) \
  X(310, process_vm_readv) \
  X(311, process_vm_writev) \
  X(312, kcmp) \
  X(313, finit_module) \
  X(314, sched_setattr) \
  X(315, sched_getattr) \
  X(316, renameat2) \
  X(317, seccomp) \
  X(318, getrandom) \
  X(319, memfd_create) \
  X(320, kexec_file_load) \
  X(321, bpf) \
  X(322, execveat) \
  X(323, userfaultfd) \
  X(324, membarrier) \
  X(325, mlock2) \
  X(326, copy_file_range) \
  X(327, preadv2) \
  X(328, pwritev2) \
  X(329, pkey_mprotect) \
  X(330, pkey_alloc) \
  X(331, pkey_free) \
  X(332, statx) \
  X(333, io_pgetevents) \
  X(334, rseq) \
  X(424, pidfd_send_signal) \
  X(425, io_uring_setup) \
  X(426, io_uring_enter) \
  X(427, io_uring_register) \
  X(428, open_tree) \
  X(429, move_mount) \
  X(430, fsopen) \
  X(431, fsconfig) \
  X(432, fsmount) \
  X(433, fspick) \
  X(434, pidfd_open) \
  X(435, clone3) \
  X(436, close_range) \
  X(437, openat2) \
  X(438, pidfd_getfd) \
  X(439, faccessat2) \
  X(440, process_madvise) \
  X(441, epoll_pwait2) \
  X(442, mount_setattr) \
  X(443, quotactl_fd) \
  X(444, landlock_create_ruleset) \
  X(445, landlock_add_rule) \
  X(446, landlock_restrict_self) \
  X(447, memfd_secret) \
  X(448, process_mrelease) \
  X(449, futex_waitv) \
  X(450, set_mempolicy_home_node)

#define X_SYSENUM(a, b) b = a,
enum class Syscall {
  SYSCALL_TABLE(X_SYSENUM)
};

const std::string get_syscall(int id);
bool operator==(const long int A, const Syscall &B);

#undef X_SYSENUM
